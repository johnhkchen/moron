---
id: T-009-01
story: S-009
title: animation-execution-engine
type: task
status: done
priority: high
phase: done
depends_on: []
blocks: [T-009-02]
---

## Context

Animation techniques exist (FadeIn, FadeUp, Slide, Scale, CountUp, Stagger) and produce `TechniqueOutput` with opacity, translate_x/y, scale, and rotation. The React renderer correctly applies these transforms via inline CSS. But `compute_frame_state()` in `frame.rs` ignores all animation segments — every visible element gets hardcoded `opacity: 1.0, scale: 1.0` with zero translation/rotation.

The gap has three parts:

1. **No technique storage.** `m.play(technique)` records `Segment::Animation { name, duration }` on the timeline but discards the technique object. There's nothing to call `apply()` on later.

2. **No animation targeting.** There's no record of which element(s) an animation applies to. The implicit convention is "the most recently created element(s)", but this isn't stored anywhere.

3. **No progress computation.** `compute_frame_state()` never maps the current time to a progress value within an animation segment or calls any technique's `apply()` method.

### Relevant code

- `moron-core/src/facade.rs` — `M::play()` (line ~250) discards the technique after extracting name/duration
- `moron-core/src/timeline.rs` — `Segment::Animation { name: String, duration: f64 }` stores only metadata
- `moron-core/src/frame.rs` — `compute_frame_state()` (line ~121) hardcodes element visuals
- `moron-techniques/src/technique.rs` — `Technique` trait is object-safe (`name()`, `duration()`, `apply()`)
- `moron-techniques/src/reveals.rs`, `motion.rs`, `staging.rs`, `data.rs` — concrete technique impls

## Acceptance Criteria

- `M::play()` stores the technique object (as `Box<dyn Technique>`) and the target element ID(s)
- Animation records are accessible to `compute_frame_state()` via a new accessor on `M`
- `compute_frame_state()` computes animation progress at the current time and applies `technique.apply(progress)` to the target element's visual state (opacity, translate_x/y, scale, rotation)
- Elements with no active animation retain current default behavior (opacity 1.0 when visible)
- Elements mid-animation show intermediate visual states (e.g., FadeIn at progress 0.5 → opacity 0.5)
- Existing tests continue to pass; new tests cover animation execution at start/mid/end progress
- `cargo test` passes, `cargo clippy` clean

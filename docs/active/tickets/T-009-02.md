---
id: T-009-02
story: S-009
title: per-item-animation-state
type: task
status: done
priority: high
phase: done
depends_on: [T-009-01]
blocks: [T-009-04]
---

## Context

`Stagger<T>` wraps an inner technique and provides `apply_item(index, progress)` to compute per-item animation state — it correctly handles staggered delay offsets and per-item progress normalization. But there's nowhere to put per-item visual state in the rendering pipeline.

Today, `ElementState.items` is `Vec<String>` — just text, no transforms. When a Stagger animation targets a Steps element, every item gets the same animation applied (the element-level transform). Items can't fade in one by one.

The React side renders Steps items as plain `<div>` elements with no individual transform props. The TypeScript `ElementState.items` type is `string[]`.

This ticket adds per-item visual state to the Rust→React contract so Stagger can animate each bullet independently.

### Relevant code

- `moron-techniques/src/staging.rs` — `Stagger.apply_item(index, progress)` (line ~43)
- `moron-core/src/frame.rs` — `ElementState { items: Vec<String>, .. }` (line ~44)
- `packages/ui/src/types.ts` — `items: string[]` (line ~48)
- `packages/ui/src/MoronFrame.tsx` — Steps rendering (line ~148), maps items to plain divs

## Acceptance Criteria

- `ElementState.items` becomes a richer type carrying per-item visual transforms (opacity, translate_x/y, scale, rotation) alongside the text
- `compute_frame_state()` calls `Stagger.apply_item(i, progress)` for each item in a Steps element when a Stagger animation is active
- Items not yet reached by the stagger delay start at the inner technique's initial state (e.g., opacity 0 for FadeIn)
- React `MoronFrame` applies per-item transforms (opacity, CSS transform) when rendering Steps items
- TypeScript types updated to match the new Rust serde output
- Unit tests verify per-item state at different stagger progress points
- `cargo test` passes, `cargo clippy` clean, React app builds

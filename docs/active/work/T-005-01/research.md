# T-005-01 Research: FFmpeg Encoding

## Objective

Map the codebase to understand how FFmpeg encoding fits into the moron-core rendering pipeline.

## Existing Module: moron-core/src/ffmpeg.rs

The current file is a stub containing only a doc comment:

```rust
//! FFmpeg pipeline: frame encoding, muxing, and output format handling.
```

No types, functions, or imports exist yet. This is a clean slate.

## Upstream: Renderer Output (moron-core/src/renderer.rs)

The renderer produces numbered PNG frames in a directory:
- Pattern: `frame_000000.png`, `frame_000001.png`, ... (6-digit zero-padded)
- Generated by `frame_path()` helper: `format!("frame_{:06}.png", frame_num)`
- `RenderResult` returns `output_dir: PathBuf` and `total_frames: u32`
- The renderer uses `RenderConfig` which contains `output_dir: PathBuf`
- FPS comes from `m.timeline().fps()` (default 30, configurable via `TimelineBuilder`)

The renderer explicitly states: "The output directory of numbered PNGs is consumed by the FFmpeg encoding pipeline (S-005) to produce the final video."

## Module Registration: moron-core/src/lib.rs

`pub mod ffmpeg;` is already declared in lib.rs (line 8). No re-exports from ffmpeg yet.
The file re-exports key types from other modules at crate root and in the prelude.
Pattern: `pub use module::{Type1, Type2, function};`

## Dependencies: moron-core/Cargo.toml

Available dependencies relevant to FFmpeg work:
- `thiserror` (workspace) -- used throughout for error types
- `std::process::Command` -- stdlib, no extra dependency needed
- No FFmpeg Rust bindings are used or wanted (per ticket)

## Error Pattern

All modules use `thiserror::Error` derive for error enums:
- `RenderError` in renderer.rs: variants like `Bridge(#[from])`, `OutputDir { path, source }`, `Serialize`, `WriteFrame`
- `BridgeError` in chromium.rs: variants like `LaunchFailed`, `ChromeNotFound`, `PageLoadFailed`
- Pattern: descriptive `#[error("...")]` messages with Display fields embedded

## Config Pattern

Modules define a Config struct with builder-like `new()`:
- `RenderConfig::new(output_dir, bridge_config)` -- sets defaults, fields are public
- `BridgeConfig::new(html_path)` -- defaults to 1920x1080, headless, 20s timeout
- Fields are `pub` for direct construction

## Timeline API

`Timeline` provides:
- `fps() -> u32` -- configured FPS
- `total_frames() -> u32` -- frame count
- `total_duration() -> f64` -- duration in seconds
- Default FPS is 30 (`DEFAULT_FPS` constant)

## FFmpeg CLI Patterns

The standard FFmpeg command for PNG-to-H.264:
```
ffmpeg -y -framerate 30 -i input_dir/frame_%06d.png -c:v libx264 -pix_fmt yuv420p -crf 23 output.mp4
```

Key flags:
- `-y`: overwrite output without asking
- `-framerate`: input frame rate
- `-i`: input pattern with `%06d` for 6-digit numbering
- `-c:v libx264`: H.264 codec
- `-pix_fmt yuv420p`: pixel format for maximum compatibility
- `-crf`: quality (0-51, lower = better, 23 = default)
- `-vf scale=W:H`: optional resolution scaling

## FFmpeg Detection

Two approaches:
1. `Command::new("ffmpeg").arg("-version").output()` -- portable, checks actual execution
2. `which ffmpeg` -- POSIX only, less reliable

Approach 1 is preferred: it works on all platforms, verifies the binary runs, and gives version info.

## Synchronous vs Async

The ticket specifies `std::process::Command` (synchronous). This is appropriate because:
- FFmpeg runs as a single long-lived subprocess
- The caller waits for encoding to complete before proceeding
- No need for async I/O; the process handles its own I/O

## Integration Point

After `render()` completes, the caller has a `RenderResult` with `output_dir` and `total_frames`.
The FFmpeg encode function takes that directory as input and produces a .mp4.
This is a sequential pipeline: render frames, then encode video.

## Constraints

- Air-gapped operation: FFmpeg must be locally installed (no downloads)
- Solo maintainable: keep the module simple, ~200 lines
- LLM-first: config should be straightforward for generated code

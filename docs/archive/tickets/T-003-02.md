---
id: T-003-02
story: S-003
title: implement-core-techniques
type: task
status: done
priority: medium
phase: done
depends_on: [T-002-05]
blocks: [T-003-04]
---

## Context

Implement the core animation techniques with actual interpolation logic. Replace the `todo!()` bodies from T-002-02 with real implementations. Each technique computes a visual state (opacity, position, scale) given a progress value (0.0 to 1.0).

Implement:
- `TechniqueOutput` struct: opacity (f64), translate_x/y (f64), scale (f64), rotation (f64)
- Update Technique trait: `fn apply(&self, progress: f64) -> TechniqueOutput`
- FadeIn: opacity 0->1
- FadeUp: opacity 0->1 + translate_y from offset to 0
- Slide: translate_x from offset to 0
- Scale: scale from small to 1.0
- Stagger: applies inner technique with staggered delays per item
- Easing: implement actual easing math for Linear, EaseIn, EaseOut, EaseInOut, OutBack, Spring

Files: moron-techniques/src/technique.rs, moron-techniques/src/reveals.rs, moron-techniques/src/motion.rs, moron-techniques/src/staging.rs

## Acceptance Criteria

- TechniqueOutput struct with opacity, position, scale fields
- FadeIn at progress 0.0 -> opacity 0, at 1.0 -> opacity 1
- FadeUp combines opacity and translation
- Easing functions produce correct curves (OutBack overshoots, Spring bounces)
- Stagger distributes progress across items
- `cargo test` passes with technique unit tests
- At least 8 unit tests covering different techniques and easing curves
